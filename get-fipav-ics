#!/usr/bin/env python3

"""
This script retrieves data from the FIPAV website and converts it into an iCalendar file (.ics).
The script takes command line arguments for the season, series, phase, group, and team.
It then sends a GET request to the FIPAV website to retrieve the data.
The data is in CSV format and is parsed using the pandas library.
Each row of the CSV represents an event, which is then converted into an iCalendar event.
The iCalendar events are added to a calendar and serialized into an iCalendar file.
The resulting iCalendar file is written to stdout.
"""

# Import necessary modules
import argparse # to parse command line arguments
from io import StringIO # to create a file-like object from a string
import pandas as pd  # to work with the data
from datetime import datetime, timedelta # to work with dates and times
import pytz  # to work with timezones
from ics import Calendar, Event  # to create an iCalendar file
import requests # to make HTTP requests
import sys # to write to stdout
from urllib.parse import quote # to encode the location as url

# Create an argument parser
parser = argparse.ArgumentParser()
parser.add_argument('stagione', help='Stagione')
parser.add_argument('serie', help='Serie')
parser.add_argument('fase', help='Fase')
parser.add_argument('girone', help='Girone')
parser.add_argument('squadra', help='Squadra')

# Parse the arguments: all the arguments are mandatory
args = parser.parse_args()

def retrieve_fipav_data(stagione, serie, fase, girone, squadra):

    # URL to the FIPAV website
    url = f'https://www.sol.milano.federvolley.it/sol/webRisultati/Calendari.aspx?serie={serie}&fase={fase}&girone={girone}&squadra={squadra}&stagione={stagione}'

    # GET request to the URL and extract cookies from headers
    response = requests.get(url)
    cookies = response.cookies

    # extract the value of the input field "ctl00$idserie" from the response text
    idserie_start = response.text.find('ctl00_idserie" value="') + len('ctl00$idserie" value="')
    idserie_end = response.text.find('"', idserie_start)
    idserie = response.text[idserie_start:idserie_end]

    # Define the headers and data for the POST request
    headers = {
        'authority': 'www.sol.milano.federvolley.it',
        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
        'accept-language': 'en-GB,en-US;q=0.9,en;q=0.8',
        'cache-control': 'no-cache',
        'content-type': 'application/x-www-form-urlencoded',
        'cookie': f'ASP.NET_SessionId={cookies["ASP.NET_SessionId"]}; .ASPXANONYMOUS={cookies[".ASPXANONYMOUS"]}',
        'origin': 'https://www.sol.milano.federvolley.it',
        'pragma': 'no-cache',
        'referer': f'{url}',
        'sec-ch-ua': '"Not A(Brand";v="99", "Google Chrome";v="121", "Chromium";v="121"',
        'sec-ch-ua-mobile': '?1',
        'sec-ch-ua-platform': '"Android"',
        'sec-fetch-dest': 'document',
        'sec-fetch-mode': 'navigate',
        'sec-fetch-site': 'same-origin',
        'sec-fetch-user': '?1',
        'upgrade-insecure-requests': '1',
        'user-agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Mobile Safari/537.36',
    }

    data = {
        '__EVENTTARGET' : 'ctl00$contentrisultati$btnStampaSq',
        '__EVENTARGUMENT' : '',
        '__LASTFOCUS' : '',
        'ctl00$iframe' : 'False',
        'ctl00$idfase' : '',
        'ctl00$idserie' : f'{idserie}',
        'ctl00$idgirone' : '',
        'ctl00$idsquadra' : f'{squadra}',
        'ctl00$idstagione' : f'{stagione}',
        'ctl00$tipocamp' : f'{girone}',
        'ctl00$nomenu' : '',
        'ctl00$h' : '240',
        'ctl00$stagione' : f'{stagione}',
        'ctl00$serie' : f'{idserie}',
        'ctl00$girone' : '**',
        'ctl00$squadra' : f'{squadra}',
        'ctl00$contentrisultati$SerieBase' : '',
        'ctl00$contentrisultati$csvmode' : 'on'
    }

    response = requests.post(url, headers=headers, data=data)
    return response.text

def process_fipav_data(input):
    # CSV content is in input
    # strip '=' from the csv file
    input = input.replace('="', '"')
    # Create a StringIO object from the response text
    # This allows us to use the csv module to read the content
    csv_file = StringIO(input)

    # Read the CSV file
    # The file is separated by semicolons
    df = pd.read_csv(csv_file, sep=';')

    # Define the timezone
    timezone = 'Europe/Rome'

    # Create a new calendar
    cal = Calendar(creator='Fabulus-Fipav-ICS')

    # get stagione from the first row
    stagione = datetime.strptime(df['DATA'][0],'%d/%m/%Y').year

    # Create a calendar name
    calendar_name = f"FIPAV-{stagione}-{df['CAMPIONATO'][0]}-{df['FASE'][0]}-{df['GIRONE'][0]}"
    cal.name = calendar_name

    # Iterate over the rows of the DataFrame
    # Each row represents an event
    for _, row in df.iterrows():

        # Create an event with a predictable UID
        event = Event(uid=f"{calendar_name}-{row['PARTITA']}")

        # Set the event details
        # The details are obtained from the current row of the DataFrame
        event.name = f"[{row['CAMPIONATO']}] {row['OSPITANTE']} vs {row['OSPITE']}"
        event.location = f"{row['CAMPO']} {row['VIA']} {row['COMUNE']}"
        event.description = f"Campionato:\n{row['DESCAMPIONATO']}\nPartita: {row['PARTITA']}\nGiornata: {row['GIORNATA']}\n"

        # Combine date and time into a datetime object
        dt = datetime.strptime(f"{row['DATA']} {row['ORA']}", '%d/%m/%Y %H:%M')

        # Localize the datetime object to the defined timezone
        dt = pytz.timezone(timezone).localize(dt)

        # Set the start and end times of the event
        event.begin = dt
        event.end = dt + timedelta(hours=2)

        # Set the creation/last-update time of the event
        event.created = datetime.now()    

        # create a description with the results of the match are not zero
        if row['SETS_OSPITANTE'] != 0 or row['SETS_OSPITE'] != 0:
            event.name += f" [{row['SETS_OSPITANTE']}-{row['SETS_OSPITE']}]"
            event.description = f"Risultato: {row['SETS_OSPITANTE']}-{row['SETS_OSPITE']}"
            punteggio = row['PUNTEGGIO'].replace('=', '').replace('"', '')
            event.description += f"\nPunteggio: {punteggio}"

        # encode the location as url
        map_location = quote(event.location)

        # add google maps link to the description
        event.description += "\n\nhttps://www.google.com/maps/search/?api=1&query=" + map_location + "\n"

        # Add the event to the calendar
        cal.events.add(event)

    # Get the iCalendar representation of the calendar
    # The serialize method returns a string that represents the calendar in the iCalendar format
    ics_str = cal.serialize()
    ics_str += "\r\n"

    return ics_str

# wrap lines longer than 75 characters according to RFC5545
def wrap_lines(ics_str):
    lines = ics_str.split("\r\n")
    wrapped_lines = []
    for line in lines:
        if len(line) <= 72:
            wrapped_lines.append(line)
        else:
            wrapped_lines.append("\r\n ".join([line[i:i+72] for i in range(0, len(line), 72)]))
    return "\r\n".join(wrapped_lines)

# Call the function with the command line arguments
input = retrieve_fipav_data(args.stagione, args.serie, args.fase, args.girone, args.squadra)

# Call the function with the input
ics_str = process_fipav_data(input)

# Call the function
ics_str = wrap_lines(ics_str)

# write calendar to stdout
sys.stdout.write(ics_str)

